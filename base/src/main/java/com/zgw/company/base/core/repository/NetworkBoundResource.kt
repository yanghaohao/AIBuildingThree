package com.zgw.company.base.core.repositoryimport androidx.annotation.MainThreadimport androidx.annotation.WorkerThreadimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MediatorLiveDataimport androidx.lifecycle.MutableLiveDataimport com.zgw.company.base.core.api.ApiEmptyResponseimport com.zgw.company.base.core.api.ApiErrorResponseimport com.zgw.company.base.core.api.ApiResponseimport com.zgw.company.base.core.api.ApiSuccessResponseimport com.zgw.company.base.core.ext.isBlankimport com.zgw.company.base.core.vo.Resourceimport com.zgw.company.base.core.vo.Statusimport io.reactivex.Observableimport io.reactivex.schedulers.Schedulersabstract class NetworkBoundResource<ResultType, RequestType> @MainThread constructor() {    private val result = MediatorLiveData<Resource<ResultType>>()    fun asLiveData(): LiveData<Resource<ResultType>> = result    protected val liveData: MutableLiveData<RequestType> = MutableLiveData()    init {        result.value = Resource(Status.LOADING)        result.value?.setOnCancelListener { cancel() }        @Suppress("LeakingThis")        val dbSource = loadFromDb()        if (dbSource.hasActiveObservers().not()) {            fetchFromNetwork(dbSource)        } else {            result.addSource(dbSource) { resultType ->                result.removeSource(dbSource)                if (shouldFetch(resultType)) {                    fetchFromNetwork(dbSource)                } else {                    result.addSource(dbSource) { result.value = result.value?.success(it) }                }            }        }    }    @MainThread    private fun setValue(newValue: Resource<ResultType>) {        if (result.value != newValue) {            result.value = newValue        }    }    private lateinit var apiResponse: LiveData<ApiResponse<RequestType>>    private fun fetchFromNetwork(dbSource: LiveData<ResultType>) {        apiResponse = createCall()        result.addSource(dbSource) { result.value?.loading()?.let { setValue(it) } }        result.addSource(apiResponse) { response ->            result.removeSource(apiResponse)            result.removeSource(dbSource)            when (response) {                is ApiSuccessResponse -> {                    if (isBlank(response.data)) {                        result.value = result.value?.success()                        return@addSource                    }                    processResponse(response)?.let {                        Observable.fromCallable { saveCallResult(it) }.subscribeOn(Schedulers.io())                            .subscribe()                    }                    result.addSource(loadFromDb()) { resultType ->                        result.value = result.value?.success(resultType)                    }                }                is ApiErrorResponse -> {                    onFetchFailed()                    if (dbSource.hasActiveObservers()) {                        result.addSource(dbSource) { it ->                            result.value = result.value?.error(it, response.errorMessage)                        }                    } else {                        result.value = result.value?.error(message = response.errorMessage)                    }                }                is ApiEmptyResponse -> result.addSource(loadFromDb()) { newData ->                    result.value = result.value?.success(newData)                }            }        }    }    @WorkerThread    protected open fun processResponse(response: ApiSuccessResponse<RequestType>) = response.data    @WorkerThread    protected abstract fun saveCallResult(item: RequestType)    @MainThread    protected abstract fun shouldFetch(data: ResultType?): Boolean    @MainThread    protected abstract fun loadFromDb(): LiveData<ResultType>    @MainThread    protected abstract fun createCall(): LiveData<ApiResponse<RequestType>>    @MainThread    protected open fun onFetchFailed() {}    @MainThread    private fun cancel() {        result.removeSource(apiResponse)    }}